#!/bin/python


import rpy2.robjects as robjects # Imports R objects into python and other shenanigans
import rpy2.robjects.packages as rpackages #Package management
r = robjects.r # Makes things more readable. r is called only with r.


# import R's utility package and select a mirror
utils = rpackages.importr('utils')


#Check if rsm is installed, and if not install it!
if not rpackages.isinstalled('rsm'):
    try:
        utils.chooseCRANmirror(ind=1) #This will error if no internet connection exists
        print("An R package called rsm package will now be installed for response surface modeling")
        utils.install_packages('rsm')
    except:
        print("------")
        print("An error occured getting the required R package (rsm)\nPlease make sure you have an internet connection")


rsm = rpackages.importr('rsm')



###### Parse input and make appropriate lists

r('''

        #function that takes csv file as input and returns dataframe
        open_csv <- function(csv_name) {
           dataframe <- read.csv(csv_name)
           return(dataframe)}

        #Function that checks if dataframe is coded or not, and outputs to csv.
        write_csv <- function(dataframe, csv_out_name) {
            if (is.coded.data(dataframe) == FALSE) {
                write.csv(dataframe, csv_out_name, row.names=FALSE)}
           else {
            write.csv(decode.data(dataframe), csv_out_name, row.names=FALSE)}
            }

        # Function that takes in the dataframe and parses it to create the variables required. returns them to python because they might not be defined in the global R environment if they were simply generated by the function.
        parse_dataframe <- function(dataframe) {

         #If "run.order" exists, it means it's a dataframe previously made by the script
            if("run.order" %in% colnames(dataframe)) {
                if("Results" %in% colnames(dataframe)) {
                    #PARSE FOR RESULTS

                }
                    else {
                     # Has run.order but not Results??
                }
                }
                else {
                # Does not have "run.order", must be an input for generating the design
                vls <- as.numeric(dataframe[1,])
                dvt <- as.numeric(dataframe[2,])
                var_names <- colnames(dataframe)
                return(vls)
                }


            return("ITS THERE")
        }

        ''')


open_csv = r['open_csv']
write_csv = r['write_csv']
parse_dataframe = r['parse_dataframe']



dataframe = open_csv("BBD_Input.csv")
robjects.globalenv['dataframe'] = dataframe
# list_return = parse_dataframe('dataframe')
# print(list_return)



colnames = r('colnames(dataframe)')

print(parse_dataframe(dataframe))
# print(dataframe)


print("-------------------")
print(colnames)

write_csv(dataframe, "test_csv.csv")

print("~~~~~~~~~~~~")

# This code is not needed since we are evaluating the variables directly in R
py_vls = [250, 60, 260, 10, 290]
py_dvt = [250, 60, 260, 10, 290]
py_var_names = ["PARSE"]

vls = robjects.FloatVector(py_vls)
dvt = robjects.FloatVector(py_dvt)
factor = robjects.FloatVector(factor)
first_var_names = robjects.StrVector(["run.order", "std.order"])
var_names = robjects.StrVector(py_var_names)
last_var_name = robjects.StrVector(["Results"])

# Export variables to the R global environment
robjects.globalenv['vls'] = vls
robjects.globalenv['dvt'] = dvt
robjects.globalenv['first_var_names'] = first_var_names
robjects.globalenv['var_names'] = var_names
robjects.globalenv['last_var_name'] = last_var_name


print(r("vls[[1]]"))
print(r("dvt[[1]]"))

#Generating a Box-Behnken design
r('''
design <- bbd(3, block = FALSE, randomize = FALSE,  coding =
    list(x1 ~ (a - vls[[1]])/dvt[[1]], x2 ~ (b - vls[[2]])/dvt[[2]], x3 ~ (c - vls[[3]])/dvt[[3]] ))
    ''')


print(r("design"))
print("~~~~~~~~~~~~")























# # import packages
# base = rpackages.importr('base')
# utils = rpackages.importr('utils')
# rsm = rpackages.importr('rsm')

# rsm.chooseCRANmirror(ind=1)

# packnames = ('ggplot2', 'hexbin', 'rsm')

# # Selectively install what needs to be install.
# # We are fancy, just because we can.
# names_to_install = [x for x in packnames if not rpackages.isinstalled(x)]
# if len(names_to_install) > 0:
#     rsm.install_packages(StrVector(names_to_install))










exit()
